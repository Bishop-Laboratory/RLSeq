---
title: "Analyzing R-loop data with RLSeq"
author:
  - name: "Henry Miller"
    affiliation: 
      - Alex Bishop Laboratory, UT Health San Antonio
      - Bioinformatics Research Network
package: RLSeq
abstract: |
  This vignette covers basic usage of RLSeq for evaluating data quality and analyzing R-loop locations. RLSeq is part of [RLSuite](https://gccri.bishop-lab.uthscsa.edu/rlsuite/){target="_blank"}, an R-loop analysis toolchain. RLSuite also includes [RLHub](https://github.com/Bishop-Laboratory/RLHub){target="_blank"}, [RLBase](https://github.com/Bishop-Laboratory/RLBase){target="_blank"} ([web interface](https://gccri.bishop-lab.uthscsa.edu/rlbase/){target="_blank"}), and [RLPipes](https://github.com/Bishop-Laboratory/RLPipes){target="_blank"}.
output: 
  BiocStyle::html_document:
    toc_float: true
    toc_depth: 3
  BiocStyle::pdf_document: default
vignette: >
  %\VignetteIndexEntry{Analyzing R-loop Data with RLSeq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, 
                      error = FALSE,
                      warning = FALSE)
BiocStyle::markdown()
```

# Introduction <img src="https://rlbase-data.s3.amazonaws.com/misc/assets/whitebgRLSeq+Logo.png" align="right" alt="logo" width="240" style = "border: none; float: right;">

**RLSeq** is a package for analyzing R-loop mapping data sets, and it is a core component of the *RLSuite* toolchain. It serves two primary purposes: (1) to facilitate the evaluation of data quality, and (2) to enable R-loop data analysis in the context of genomic annotations and the public data sets in [RLBase](https://gccri.bishop-lab.uthscsa.edu/rlbase/){target="_blank"}. The main analysis steps can be conveniently run using the  `RLSeq()` function. Then, an HTML report can be generated using the `report()` function. Individual steps of this pipeline are also accessible through separate functions which provide custom analysis capabilities.

This vignette will showcase the primary functionality of RLSeq with data from a publicly-available R-loop data mapping study in Ewing sarcoma cell lines, [GSE68845](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE68845){target="_blank"}. We have selected two DNA-RNA Immunoprecipitation sequencing (DRIP-seq) samples for demonstration purposes: (1) [SRX1025890](https://www.ncbi.nlm.nih.gov/sra/SRX1025890){target="_blank"}, a positive R-loop mapping sample ("POS"; condition: S9.6 -RNaseH1), and (2) [SRX1025892](https://www.ncbi.nlm.nih.gov/sra/SRX1025892){target="_blank"}, a negative control ("NEG"; condition S9.6 +RNaseH1). We will begin by showing a quick-start analysis on *SRX1025890*, and then we will proceed to discuss, in detail, the specific steps of this analysis with both samples.

# Quick-start

Here, we demonstrate a simple analysis workflow which utilizes a publicly-available data set stored in [*RLBase*](https://gccri.bishop-lab.uthscsa.edu/rlbase/){target="_blank"} (a database of R-loop consensus regions and R-loop-mapping experiments, also part of [*RLSuite*](https://gccri.bishop-lab.uthscsa.edu/rlsuite/){target="_blank"}). The commands below download these data, run `RLSeq()`, and generate the HTML report.

``` {.r}
# Peaks and coverage can be found in RLBase
rlbase <- "https://rlbase-data.s3.amazonaws.com"
pks <- file.path(rlbase, "peaks", "SRX1025890_hg38.broadPeak")
cvg <- file.path(rlbase, "coverage", "SRX1025890_hg38.bw")

# Initialize data in the RLRanges object. 
# Metadata is optional, but improves the interpretability of results
rlr <- RLRanges(
  peaks = pks,
  coverage = cvg,
  genome = "hg38",
  mode = "DRIP",
  label = "POS",
  sampleName = "TC32 DRIP-Seq"
)

# The RLSeq command performs all analyses
rlr <- RLSeq(rlr)

# Generate an html report
report(rlr, reportPath = "rlseq_report.html")
```

The report generated by this code is found [here](https://rlbase-data.s3.amazonaws.com/reports/SRX1025890_hg38.html){target="_blank"}.

# Preliminary

## Installation

RLSeq should be installed alongside [RLHub](https://github.com/Bishop-Laboratory/RLHub){target="_blank"} to facilitate access to the data required for annotation and analysis. When downloading RLSeq from bioconductor, RLHub is already included.

``` {.r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("RLSeq")
```

Both packages can also be installed from github.

``` {.r}
library(remotes)
install_github("Bishop-Laboratory/RLHub")
install_github("Bishop-Laboratory/RLSeq")
```

## Obtaining data

<br>

<details>
<summary>Obtaining data from raw files with `RLPipes`</summary>

RLSeq is compatible with R-loop data generated from a variety of pipelines and tools. *However*, it is strongly recommended that you use [RLPipes](https://github.com/Bishop-Laboratory/RLPipes){target="_blank"}, a snakemake-based CLI pipeline tool built specifically for upstream processing of R-loop datasets. 

RLPipes can be installed using [mamba](https://anaconda.org/conda-forge/mamba){target="_blank"} or [conda](https://docs.conda.io/en/latest/miniconda.html){target="_blank"} (slower).

``` {.shell}
# conda install -c conda-forge mamba
mamba create -n rlpipes -c bioconda -c conda-forge rlpipes
conda activate rlpipes
```

A typical config file `CSV` file should be written as such:

| experiment |
|:---------- |
| SRX1025890 |
| SRX1025892 |

And then the pipeline can be run.

``` {.shell}
RLPipes build -m DRIP rseq_out/ tests/test_data/samples.csv
RLPipes run rseq_out/
```

The resulting directory will contain `peaks/`, `coverage/`, `bam/`, and other processed data sets which are directly compatible with RLSeq.

*Note*: If you choose to use a different pipeline, use [macs2/macs3](https://github.com/macs3-project/MACS){target="_blank"} for peak calling to ensure compatibility with RLBase.

</details>

<br>

# End-to-end RLSeq

Here, we describe each step of the analysis pipeline which is run as part of the `RLSeq()` command.

```{r library, echo=FALSE}
library(RLSeq)
library(dplyr)
```

## Data sets

For this example, we will be using data from a 2018 *Nature* paper on R-loops in Ewing sarcoma [@Gorthi2018a]. Two samples are used, one which has been IP'd for R-loops (S9.6 -RNaseH1; label: **"POS"**), and one which is the same, but with the addition of an RNaseH1 treatment (S9.6 +RNaseH1; label: **"NEG"**). RNaseH1 treatment degrades RNA:DNA hybrids (a core component of R-loops), so it serves as a useful negative control in these types of studies.

| experiment | condition      |
|:---------- |:-------------- |
| SRX1025890 | S9.6 - RNaseH1 |
| SRX1025892 | S9.6 + RNaseH1 |

: R-loop mapping samples in Ewing sarcoma cells

The data was processed using RLPipes and uploaded to RLBase. Peaks are converted to `GRanges` objects using a helper function from `regioneR`.

```{.r}
rlbase <- "https://rlbase-data.s3.amazonaws.com"

# Get peaks and coverage
s96Pks <- regioneR::toGRanges(file.path(rlbase, "peaks", "SRX1025890_hg38.broadPeak"))
s96Cvg <- file.path(rlbase, "coverage", "SRX1025890_hg38.bw")
rnhPks <- regioneR::toGRanges(file.path(rlbase, "peaks", "SRX1025892_hg38.broadPeak"))
rnhCvg <- file.path(rlbase, "coverage", "SRX1025892_hg38.bw")
```

For demonstration purposes, only 10000 ranges from the positive (S9.6 -RNaseH1) sample are analyzed here. 

```{.r}
# For expediency, peaks we filter and down-sampled to the top 10000 by padj (V9)
# This is not necessary as part of the typical workflow, however
s96Pks <- s96Pks[s96Pks$V9 > 2,]
s96Pks <- s96Pks[sample(names(s96Pks), 10000)]
```

Finally, `RLRanges` objects were constructed. These are the primary objects used in all `RLSeq` functions. `RLRanges` are an extension of `GRanges` which provide additional metadata and validation functions.

```{.r}
## Build RLRanges ##
# S9.6 -RNaseH1
rlr <- RLRanges(
  peaks = s96Pks, 
  coverage = s96Cvg,
  genome = "hg38",
  mode = "DRIP",
  label = "POS",
  sampleName = "TC32 DRIP-Seq",
  quiet = TRUE
)

# S9.6 +RNaseH1
rlrRNH <- RLRanges(
  peaks = rnhPks, 
  coverage = rnhCvg,
  genome = "hg38",
  mode = "DRIP",
  label = "NEG",
  sampleName = "TC32 DRIP-Seq (+RNaseH1)",
  quiet = TRUE
)
```

```{r, include=FALSE}
# For the sake of getting this to build in the allotted 5 minutes on bioc,
# we precalculated RLSeq() on the above files and stored them in extdata.
# rlr <- RLSeq(rlr)
# rlrRNH <- RLSeq(rlrRNH)
# saveRDS(rlr, file = "rlr_vgn.rds", compress = "xz")
# saveRDS(rlrRNH, file = "rlrRNH_vgn.rds", compress = "xz")
# system("aws s3 cp rlr_vgn.rds s3://rlbase-data/misc/")
# system("aws s3 cp rlrRNH_vgn.rds s3://rlbase-data/misc/")
rlr <- aws.s3::s3readRDS(object = "misc/rlr_vgn.rds", bucket = "s3://rlbase-data/")
rlrRNH <- aws.s3::s3readRDS(object = "misc/rlrRNH_vgn.rds", bucket = "s3://rlbase-data/")
```

## Sample quality

Sample quality is assessed by analyzing the association of peaks with R-loop-forming sequences (RLFS). RLFS are genomic sequences that favor the formation of R-loops [@Jenjaroenpun2015]. While R-loops can form outside RLFS, there is a noticeable relationship between R-loops and RLFS, which provides an unbiased test of whether a set of peaks actually represents successful R-loop mapping. This method is described in full within the RLSuite manuscript.

### Permutation tests

RLSeq first implements a permutation test to evaluate the enrichment of peaks within RLFS and build a Z-score distribution around the TSS.

```{.r}
# Analyze RLFS for positive sample
rlr <- analyzeRLFS(rlr, quiet = TRUE)
rlrRNH <- analyzeRLFS(rlrRNH, quiet = TRUE)
```

The resulting objects now contain the permutation test results. These results can be easily visualized with the `plotRLFSRes` function.

```{r plot-perm, fig.cap="Plot of permutation test results (S9.6 -RNaseH1)."}
plotRLFSRes(rlr)
```

As a comparison, we also view the negative control (S9.6 +RNaseH1) samples.

```{r plot-perm-rnh, fig.cap="Plot of permutation test results (S9.6 + RNaseH1)."}
plotRLFSRes(rlrRNH)
```

From this example, we can see a fundamental challenge facing RLFS-based quality assessment: while the RNaseH1-treated sample is clearly a negative control, and the distribution does not resemble examples of positive samples found in RLBase ([link](https://rlbase-data.s3.amazonaws.com/misc/examples_for_select_samples.png)), the p-value is still significant at `p < 0.0099`. This indicates that the p value from RLFS permutation testing is insufficient to distinguish successful and unsuccessful R-loop mapping. This observation motivated the development of a classifier model, which we made accessible within RLSeq.

### Classifier predictions

The classifier is an ensemble model based on an online-learning scheme as detailed in the RLSuite manuscript. The latest version can be accessed via [RLHub](https://github.com/Bishop-Laboratory/RLHub){target="_blank"}. To apply the model and predict sample quality, use the `predictCondition()` function. 

```{.r}
# Predict 
rlr <- predictCondition(rlr)
rlrRNH <- predictCondition(rlrRNH)
```

The results from testing our example samples:

```{r}
# Access results
s96_pred <- rlresult(rlr, "predictRes")
rnh_pred <- rlresult(rlrRNH, "predictRes")

# Results
dplyr::tibble(
  condition = c("S9.6 -RNaseH1", "S9.6 + RNaseH1"),
  prediction = c(s96_pred$prediction, rnh_pred$prediction)
) 
```

The resulting `prediction` from the model is either **"POS"** or **"NEG"**. *POS* means that the model predicts a sample is robustly mapping R-loops, whereas *NEG* samples are predicted to map R-loops poorly or not at all. 

## Feature enrichment

The feature enrichment test assesses the enrichment of genomic features within a supplied R-loop dataset. The function queries the RLHub annotation database to retrieve genomic features, and then it performs fisher's exact test and the relative distance test to assess feature enrichment [@Favorov2012].

```{.r}
# Perform test
rlr <- featureEnrich(
  object = rlr,
  quiet = TRUE
)
```

The results:

```{r}
# View Top Results
annoResS96 <- rlresult(rlr, "featureEnrichment")
annoResS96 %>%
  relocate(contains("fisher"), .after = type) %>%
  arrange(desc(stat_fisher_rl))
```

From the results, we see that there is high enrichment within genic features, such as exons and introns.

<br>

<details>
<summary>RNaseH1 Comparison</summary>

As a comparison, we also performed the same test with the RNaseH1-treated sample.

```{.r}
# Perform test
rlrRNH <- featureEnrich(
  object = rlrRNH,
  quiet = TRUE
)
```

The results:

```{r}
# View Top Results
annoResRNH <- rlresult(rlrRNH, "featureEnrichment")
annoResRNH %>%
  relocate(contains("fisher"), .after = type) %>%
  arrange(desc(stat_fisher_rl)) 
```

Finally, we visualized the top results for the positive and negative conditions as a heat map.

```{r}
inner_join(
  annoResRNH, 
  annoResS96,
  by = c("db", "type"),
  suffix = c("__S9.6 +RNaseH1", "__S9.6 -RNaseH1")
) %>%
  select(db, type,  contains("stat_fisher_rl")) %>%
  tidyr::pivot_longer(cols = contains("__")) %>%
  mutate(
    group = gsub(name, pattern = ".+__(.+)$", replacement = "\\1"),
    value = ifelse(value == Inf, max(value[is.finite(value)]), value),
    value = log2(value)
  ) %>%
  filter(! is.na(value),
         is.finite(value)) %>%
  group_by(group) %>%
  filter(type %in% (slice_max(., order_by = value, n = 8) %>% pull(type))) %>%
  ungroup() %>%
  distinct(type, group, .keep_all = TRUE) %>%
  select(value, group, type) %>%
  tidyr::pivot_wider(id_cols = type, names_from = group, 
                     values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "type") %>%
  as.matrix() %>%
  ComplexHeatmap::pheatmap(
    color = colorRampPalette(RColorBrewer::brewer.pal("PuBuGn", n = 9))(100), 
    main = "Top enriched features",
    name = "Fisher Log2 Ratio", 
    angle_col = "45"
  )
```

<br>

</details>

<br>

### Visualization of enrichment results

RLSeq provides a helper function, `plotEnrichment`, to facilitate the visualization of enrichment results.

```{r, warning=FALSE, figures-side, fig.show="hold", out.width="50%"}
pltlst <- plotEnrichment(rlr)
```

This returns a list of plots named according to the corresponding annotation database. For example, Encode cis-regulatory elements (CREs):

```{r warning=FALSE}
pltlst$Encode_CREs
```

<br> 

<details>
<summary>Using the `splitby` parameter</summary>

The `splitby` parameter allows for plotting with respect to `prediction` (predicted condition, ie, "POS" or "NEG") or `label` (labeled condition). This can be useful when trying to determine whether a particular annotation is uniquely-enriched in samples which robustly map R-loops.

```{r}
pltlst <- plotEnrichment(rlr, splitby = "prediction", pred_POS_only = FALSE)
```

Encode cis-regulatory elements (CREs):

```{r}
pltlst$Encode_CREs
```

</details>

<br>

<details>
<summary>**Note**: Caveat on data range</summary>

A limitation of this approach is that Fisher's exact test sometimes returns `Inf` or `-Inf` for the statistic (odds ratio). While these results are useful in demonstrating robust enrichment or non-enrichment, they are difficult to plot in a meaningful way. As a compromise, `plotEnrichment` sets a limited data range of -10 through 15. These values were chosen because they encompass every finite value that can be returned from the implementation of Fisher's test which RLSeq uses. In the above plots `Inf` results are shown on the y-axis at value `15` and, likewise, `-Inf` is shown at `-10`. 

</details>

<br>

## Correlation analysis

Correlation analysis finds inter-sample correlation coefficients of bin-level R-loop signal around gold-standard R-loop sites (sites profiled using ultra-long-read R-loop mapping -- "SMRF-Seq") [@Ch√©din2021]. This analysis helps to answer the question "how well does my data agree with previous results?"

```{.r}
rlr <- corrAnalyze(rlr)
```

The results of this analysis are visualized using `corrHeatmap`.

```{r, fig.height=5.8, fig.width=7.8}
corrHeatmap(rlr)
```
These results demonstrate that our sample correlates well with similar DRIP-Seq data sets. 

## Gene Annotation

Gene annotations are automatically downloaded using `AnnotationHub()` and then intersected with RLRanges.

```{.r}
rlr <- geneAnnotation(rlr)
```

<br>
<details>
<summary>Over-representation analysis</summary>

These results can then be used for over-representation analysis if desired. One caveat to this analysis is that the number of genes is a function of the number of peaks, and this can lead (at higher numbers) to noticeable bias in enrichment analysis.

```{r}
len <- rlresult(rlr, "geneAnnoRes") %>%
  pull(gene_id) %>%
  unique() %>%
  length()
cat(len, " genes found in RLRanges")
```

To address this, we filter RLRanges object to obtain the top 2000 ranges by p-adjusted value (`qval` in `RLRanges` objects.)

```{r}
# Pull the peak names for the top 2000 peaks
topPks <- rlr %>%
  as.data.frame() %>%
  tibble::rownames_to_column(var = "peakName") %>%
  slice_max(qval, n = 2000) %>%
  pull(peakName)

# Filter the results to obtain the corresponding genes
rlgenes <- rlresult(rlr, "geneAnnoRes") %>%
  filter(peak_name %in% {{ topPks }}) %>%
  pull(gene_id) %>%
  unique()

# Get lenght of these genes
cat(length(rlgenes), " genes found in top 2000 RLRanges")
```

Before we can perform pathway enrichment, we convert our gene IDs to gene symbols.

```{.r}
symbols <- AnnotationDbi::mapIds(
  org.Hs.eg.db::org.Hs.eg.db, 
  keys = rlgenes, 
  keytype = "ENTREZID", 
  column = "SYMBOL"
)
```

With our final list of genes prepared, we proceed to perform over-representation analysis using the [enrichr](https://maayanlab.cloud/Enrichr/){target="_blank"} web service.

```{.r}
response <- httr::POST(
  url = 'https://maayanlab.cloud/Enrichr/addList', 
  body = list(
    'list' = paste0(symbols, collapse = "\n"),
    'description' = paste0("RL-overlap Genes from ", 
                           slot(rlr, "metadata")$sampleName)
  )
)
response <- jsonlite::fromJSON(httr::content(response, as = "text"))  
permalink <- paste0(
  "https://maayanlab.cloud/Enrichr/enrich?dataset=", response$shortId[1]
)
```

The permalink to these results can be found <a href="https://maayanlab.cloud/Enrichr/enrich?dataset=28101120901011012431fd14ad417e42" target="_blank">here</a>.

</details>

<br>

## R-Loop Region Test

R-loop regions are consensus R-loop-forming sites discovered from analyzing all high-confidence R-loop mapping samples in RLBase. A description of this approach is found in the RLSuite manuscript. The `rlRegionTest()` analyzes the enrichment of the ranges in our `RLRanges` object with these consensus R-loop sites, which, like correlation analysis, also helps answer the question "how well does my data agree with previous results?"

```{.r}
rlr <- rlRegionTest(rlr)
```

The test results can be easily visualized in the following manner.

<br>

```{r}
plotRLRegionOverlap(
  object = rlr, 
  
  # Arguments for VennDiagram::venn.diagram()
  fill = c("#9ad9ab", "#9aa0d9"),
  main.cex = 2,
  cat.pos = c(-40, 40),
  cat.dist=.05,
  margin = .05
)
```

# Accessing RLBase data

For convenience, we also provide pre-analyzed `RLRanges` objects for every sample in RLBase. To access them, you need only provide the ID of the sample which you want to obtain data from. These IDs, along with other metadata, are listed in `RLHub::rlbase_samples()`.

```{r}
rlr <- RLRangesFromRLBase(acc = "SRX1025890")
rlr
```

# Session

<details>
<summary>Session info</summary>

```{r}
sessionInfo()
```

</details>


# References
