---
title: "Analyzing R-loop data with RLSeq"
author:
  - name: "Henry Miller"
    affiliation: 
      - Alex Bishop Laboratory, UT Health San Antonio
      - Bioinformatics Research Network
package: RLSeq
abstract: |
  This vignette covers basic usage of RLSeq, part of [RLSuite](www.path_to_rlsuite.com), for evaluating data quality and 
  analyzing R-loop locations in comparison with [RLBase](www.rlbase_website.com).
output: 
  BiocStyle::html_document:
    toc_float: true
  BiocStyle::pdf_document: default
params:
  newdat: 1  # I chose for a reason
vignette: >
  %\VignetteIndexEntry{Analyzing R-loop Data with RLSeq}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}  
bibliography: references.bib
---

```{r, include = FALSE}
knitr::opts_chunk$set(tidy = FALSE,
                      cache = FALSE,
                      dev = "png",
                      message = FALSE, error = FALSE, warning = TRUE)
BiocStyle::markdown()
```

# Introduction

**RLSeq** is a toolkit for analyzing and evaluating R-loop mapping data sets and it is a core component of the [RLSuite](www.path_to_rlsuite) tool chain. It serves two primary purposes: (1) to facilitate the evaluation of data quality, and (2) to enable R-loop data analysis in the context of genomic annotations and public data sets in [RLBase](www.rlbase_website.com). The package is intended to provide a simple pipeline, called with the `RLSeq()` function, which performs all main analyses and outputs a user-friendly HTML report. Individual functions are also accessible and provide custom analysis capabilities.

This vignette will showcase the primary functionality of RLSeq through an analysis of a publicly-available R-loop data set. It will proceed to discuss, in detail, the specific steps of a typical analysis along with caveats and other considerations.

# Quick-start

The following details a simple analysis workflow that can be run without any prior data, due to the availability of processed data sets in RLBase and annotations provided by RLHub. The commands below download these data sets and load the annotations. Finally, they run `RLSeq()`, which performs all core analysis steps and generates an HTML report.

``` {.r}
# Peaks and coverage can be found in RLBase
rlbase <- "https://rlbase-data.s3.amazonaws.com"
pks <- file.path(rlbase, "peaks", "SRX1025890_hg38.broadPeak")
cvg <- file.path(rlbase, "coverage", "SRX1025890_hg38.bw")

# Annotations can be found in RLHub
annot <- file.path(rlbase, "RLHub", "annotations_primary_hg38.rda")
tmp <- tempfile()
download.file(annot, destfile = tmp, quiet = TRUE)
load(tmp)

# Initialize data in the RLRanges object. 
rlr <- RLRanges(
  peaks = pks,
  coverage = cvg,
  genome = "hg38",
  mode = "DRIP"
)

# The RLSeq command performs all analysis to generate an HTML report
rls <- RLSeq(
  object=rlr,
  annotations = annotations
)
```

The report generated by this code is found [here](www.somewhere_on_internet.com).

# RLSeq in full

## Preliminary

### Installation

RLSeq should be installed alongside [RLHub](www.rlhub_location.com) to facilitate access to the data required for annotation and analysis.

``` {.r}
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("RLSeq")
```

Both packages can also be installed from github.

``` {.r}
library(remotes)
install_github("Bishop-Laboratory/RLHub")
install_github("Bishop-Laboratory/RLSeq")
```

### Obtaining processed R-loop data

RLSeq is compatible with R-loop data generated from a variety of pipelines and tools. *However*, it is strongly recommended that [macs2/macs3](https://github.com/macs3-project/MACS) is used for peak calling as this will improve compatibility with RLBase. In RLSuite, we have provided [RLPipes](www.path_to_rlpipes.com), a snakemake-based CLI pipeline tool built specifically for upstream processing of R-loop datasets. It is also the tool which was used to generate all data within RLBase.

#### RLPipes for upstream data processing

RLPipes can be installed using [mamba](https://anaconda.org/conda-forge/mamba) or [conda](https://docs.conda.io/en/latest/miniconda.html) (slower).

``` {.shell}
# conda install -c conda-forge mamba
mamba create -n rlpipes -c bioconda rlpipes
```

A typical config file `CSV` file should be written:

| experiment |
|------------|
| SRX1025890 |
| SRX1025892 |

And then the pipeline can be run.

``` {.shell}
RLPipes build -m DRIP rseq_out/ tests/test_data/samples.csv
RLPipes run rseq_out/
```

The resulting directory will contain `peaks/`, `coverage/`, `bam/`, and other processed datasets which are directly compatible with RLSeq.

## The RLSeq Workflow

The following details each step of the analysis pipeline which is run as part of the `RLSeq()` command. We will showcase the usage of each and describe important parameters.

```{r library, echo=FALSE}
library(RLSeq)
library(dplyr)
```

### Data sets

For this example, we will be using data from a 2018 *Nature* paper on R-loops in Ewing sarcoma [@Gorthi2018a]. Two samples are used, one which has been IP'd for R-loops (S9.6), and one which is the same, but with the addition of an RNaseH1 treatment (S9.6 + RNaseH1). RNaseH1 degrades RNA:DNA hybrids (a core component of R-loops), so it serves as a useful negative control.

| experiment | condition      |
|------------|----------------|
| SRX1025890 | S9.6           |
| SRX1025892 | S9.6 + RNaseH1 |

: R-loop mapping samples in Ewing sarcoma cells

The data was processed using RLPipes and uploaded to RLBase. We begin by reading in the data to `GRanges` objects using a helper function from `regioneR`.

```{r}
rlbase <- "https://rlbase-data.s3.amazonaws.com"

# Get peaks and coverage
s96Pks <- regioneR::toGRanges(file.path(rlbase, "peaks", "SRX1025890_hg38.broadPeak"))
s96Cvg <- file.path(rlbase, "coverage", "SRX1025890_hg38.bw")
rnhPks <- regioneR::toGRanges(file.path(rlbase, "peaks", "SRX1025892_hg38.broadPeak"))
rnhCvg <- file.path(rlbase, "coverage", "SRX1025892_hg38.bw")

## Build RLRanges ##

# S9.6 -RNaseH1
rlr <- RLRanges(
  peaks = s96Pks, 
  coverage = s96Cvg,
  genome = "hg38",
  mode = "DRIP",
  condType = "POS",
  sampleName = "TC32 DRIP-Seq"
)

# S9.6 +RNaseH1
rlrRNH <- RLRanges(
  peaks = rnhPks, 
  coverage = rnhCvg,
  genome = "hg38",
  mode = "DRIP",
  condType = "NEG",
  sampleName = "TC32 DRIP-Seq (+RNaseH1)"
)
```

### Sample quality

Sample quality is assessed by analyzing the association of peaks with R-loop-forming sequences (RLFS). RLFS are genomic sequences that favor the formation of R-loops [@Jenjaroenpun2015]. While R-loops can form outside RLFS, there is a noticeable relationship between R-loops and RLFS, which provides an unbiased test of whether a set of peaks actually represents successful R-loop mapping. This method is described in full within the [RLSuite publication](www.pub_link.com).

#### Permutation tests

RLSeq first implements a permutation test to evaluate the enrichment of peaks within RLFS and build a Z-score distribution around the TSS.

```{r rlfs-test, cache=TRUE}
# Analyze RLFS for positive sample
rlr <- analyzeRLFS(rlr, quiet = TRUE)
```

The resulting objects now contain the permutation test results. These results can be easily visualized with the `permPlot` function.

```{r plot-perm, fig.cap="Plot of permutation test results (S9.6)."}
plotRLFSRes(rlr)
```

As a comparison, we also test the negative control (RNaseH1-treated) samples.

```{r plot-perm-rnh, fig.cap="Plot of permutation test results (S9.6 + RNaseH1)."}
rlrRNH <- analyzeRLFS(rlrRNH, quiet = TRUE)
plotRLFSRes(rlrRNH)
```

From this example, we can see a fundamental challenge facing RLFS-based quality assessment: while the RNaseH1-treated sample is clearly a negative control, and the distribution looks terrible, the p-value is still significant at `p < 0.0099`. This indicates the flaw with permutation testing alone, and it was the motivation for the development of a classifier that could discriminate positive from negative samples. The classifier can be accessed through RLSeq.

#### Classifier predictions

The classifier is an ensemble model based on an online-learning scheme as detailed in the RLSuite publication. The latest version can be accessed via RLHub.

```{r predict-condition}

# Predict 
rlr <- predictCondition(rlr)
rlrRNH <- predictCondition(rlrRNH)

# Results
tibble::tibble(
  condition = c("S9.6", "S9.6 + RNaseH1"),
  verdict = c(s96_pred$Verdict, rnh_pred$Verdict)
) %>% 
  kableExtra::kable(format = "html") %>% 
  kableExtra::kable_classic(full_width=FALSE, font_size = 20)
```

### Feature enrichment analysis

Now that we have verified the quality of our S9.6 sample (SRX1025890), we proceed to perform a feature enrichment test. This allows us to determine what genomic features were enriched within the mapped R-loops from this data set. The test involves querying the annotation database in RLHub and performing fisher's exact test as well as the relative distance test [@Favorov2012].

```{r}

# Annotations can be found in RLHub
annot <- file.path(rlbase, "RLHub", "annotations_primary_hg38.rda")
tmp <- tempfile()
download.file(annot, destfile = tmp, quiet = TRUE)
load(tmp)

# Perform test
annoResS96 <- featureEnrich(
  peaks = s96, 
  genome = "hg38",
  annotations = annotations_primary,
  quiet = TRUE
)

# View Top Results
annoResS96 %>%
  relocate(contains("fisher"), .after = type) %>%
  arrange(desc(stat_fisher_rl)) %>%
  slice_head(n = 10) %>%
  DT::datatable()
```

From the top results (ranked by fisher's exact test odds ratio), we observe a high degree of enrichment within genic features, such as Exons and Introns, as well as regulatory features such as enhancer promoters (enhP). These results are entirely consistent with previous reports of R-loop location mapping [@Castillo-Guzman2021].

<details>

<summary>

RNaseH1 Comparison

</summary>

As a comparison, we also perform the same test with the RNaseH1-treated sample.

```{r}
# Perform test
annoResRNH <- featureEnrich(
  peaks = rnh, 
  genome = "hg38",
  annotations = annotations_primary,
  quiet = TRUE
)

# View Top Results
annoResRNH %>%
  relocate(contains("fisher"), .after = type) %>%
  arrange(desc(stat_fisher_rl)) %>%
  DT::datatable()
```

We found that the top hits were different from those uncovered in the experimental condition. Particularly, there was stark enrichment for repetitive elements and a diminished enrichment for genomic features.

To visualize these results, we construct a tidy pipe to pull the top 6 enriched annotations within experiment and control samples to visualize as a heat map.

```{r}
inner_join(
  annoResRNH, 
  annoResS96,
  by = c("db", "type"),
  suffix = c("__S9.6 +RNaseH1", "__S9.6 -RNaseH1")
) %>%
  select(db, type,  contains("stat_fisher_rl")) %>%
  tidyr::pivot_longer(cols = contains("__")) %>%
  mutate(
    group = gsub(name, pattern = ".+__(.+)$", replacement = "\\1"),
    value = log2(value)
  ) %>%
  filter(! is.na(value),
         is.finite(value)) %>%
  group_by(group) %>%
  filter(type %in% (slice_max(., order_by = value, n = 8) %>% pull(type))) %>%
  ungroup() %>%
  select(value, group, type) %>%
  tidyr::pivot_wider(id_cols = type, names_from = group, 
                     values_from = value, values_fill = 0) %>%
  tibble::column_to_rownames(var = "type") %>%
  as.matrix() %>%
  ComplexHeatmap::pheatmap(
    color = colorRampPalette(RColorBrewer::brewer.pal("PuBuGn", n = 9))(100), 
    main = "Top enriched features",
    name = "Fisher Log2 Ratio", 
    angle_col = "45"
  )
```

From this result, we plainly observe the stark contrast in enrichment between samples which map R-loops (S9.6 -RNaseH1) and those which do not (S9.6 + RNaseH1).

<br>

</details>

<br>

#### Visualization of enrichment results

RLSeq provides a helper function, `plotEnrichment`, to facilitate the visualization of enrichment results.

```{r}
# Load the RLBase enrichment results to compare with
rlbase_enrich <- file.path(rlbase, "RLHub", "feature_enrichment_per_sample.rda")
tmp <- tempfile()
download.file(rlbase_enrich, destfile = tmp, quiet = TRUE)
load(tmp)

plotEnrichment(
  sampleRes=annoResS96,
  rlbaseRes=feature_enrichment_per_sample
)
```

### Correlation analysis

Correlation analysis finds inter-sample correlation coefficients by using bin-level R-loop counts around gold-standard R-loop sites (sites profiled using ultra-long-read R-loop mapping -- "SMRF-Seq") [@Chédin2021].

# References
