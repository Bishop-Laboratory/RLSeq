dplyr::select(-location)
# Wrangle positions into tibble
posTbl <- dplyr::rename(posTbl, chrom=seqnames)
# Summarize across gs intervals with valr
bwMap <- valr::bed_map(x = posTbl, y = bw, value = sum(score))
posTbl
seqnames
bw
bw$score
# Get the locations of the gs sites
positions <- rownames(RSeqR::gsSignalRMapDB) %>%
tibble::tibble(location = .) %>%
dplyr::mutate(seqnames = gsub(location, pattern = "(.+)_(.+)_(.+)", replacement = "\\1"),
start = gsub(location, pattern = "(.+)_(.+)_(.+)", replacement = "\\2"),
end = gsub(location, pattern = "(.+)_(.+)_(.+)", replacement = "\\3")) %>%
dplyr::select(-location) %>%
GenomicRanges::makeGRangesFromDataFrame(seqinfo = rtracklayer::SeqinfoForUCSCGenome(genome))
# Read in the bigWig file using these locations
bw <- import(BigWigFile(BW_FILE), selection = positions)
# Wrangle BW into tibble
bw <- bw %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::rename(chrom=seqnames)
# Wrangle positions into tibble
posTbl <- positions %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::rename(chrom=seqnames)
# Summarize across gs intervals with valr
bwMap <- valr::bed_map(x = posTbl, y = bw, value = sum(score))
positions <- rownames(RSeqR::gsSignalRMapDB) %>%
tibble::tibble(location = .) %>%
dplyr::mutate(seqnames = gsub(location, pattern = "(.+)_(.+)_(.+)", replacement = "\\1"),
start = gsub(location, pattern = "(.+)_(.+)_(.+)", replacement = "\\2"),
end = gsub(location, pattern = "(.+)_(.+)_(.+)", replacement = "\\3")) %>%
dplyr::select(-location) %>%
GenomicRanges::makeGRangesFromDataFrame(seqinfo = rtracklayer::SeqinfoForUCSCGenome(genome))
# Read in the bigWig file using these locations
bw <- import(BigWigFile(BW_FILE), selection = positions)
# Wrangle BW into tibble
bw <- bw %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::rename(chrom=seqnames)
# Wrangle positions into tibble
posTbl <- positions %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::rename(chrom=seqnames)
# Summarize across gs intervals with valr
bwMap <- valr::bed_map(x = posTbl, y = bw, value = sum(score))
# Combine with the original matrix
combinedMat <- gsSignalRMapDB %>%
as.data.frame() %>%
tibble::rownames_to_column(var = "location") %>%
dplyr::inner_join(
bwMap %>%
dplyr::mutate(location = paste0(chrom, "_", start, "_", end)) %>%
dplyr::select(location, user_supplied=value)
) %>%
dplyr::distinct(location, .keep_all = TRUE) %>%
tibble::column_to_rownames("location") %>%
as.matrix()
# Find the correlation
corMat <- cor(combinedMat)
# Combine with the original matrix
combinedMat <- gsSignalRMapDB %>%
as.data.frame() %>%
tibble::rownames_to_column(var = "location") %>%
dplyr::inner_join(
bwMap %>%
dplyr::mutate(location = paste0(chrom, "_", start, "_", end)) %>%
dplyr::select(location, user_supplied=value),
by="location"
) %>%
dplyr::distinct(location, .keep_all = TRUE) %>%
tibble::column_to_rownames("location") %>%
as.matrix()
# Find the correlation
corMat <- cor(combinedMat)
class(RSeqR::predictCondition(RSeqR::analyzeRLFS(RSeqR::SRX1025890_peaks, genome="hg38")))
matrix(1:10)
matrix(1:10) %>% class()
matrix(1:10) %>% typeof()
library(RSeqR)
library(RSeqR)
?test_that
library(RSeqR)
usethis::use_package("valr")
usethis::use_package("EnsDb.Hsapiens.v86")
usethis::use_package("caret")
RSeqR::prepFeatures
RSeqR::prepFeatures$wildcards
RSeqR::prepFeatures$knnSummary()
# Standardize features
features <- caret:::predict.preProcess(RSeqR::prepFeatures, featuresRaw)
result <- RSeqR::analyzeRLFS(RSeqR::SRX1025890_peaks, genome="hg38")
rlfsRes <- result
# Get pval
pval <- rlfsRes$perTestResults$`regioneR::numOverlaps`$pval
# Get Z
Z <- rlfsRes$`Z-scores`$`regioneR::numOverlaps`$shifted.z.scores
# Get edge and center Z values
shifts <- rlfsRes$`Z-scores`$`regioneR::numOverlaps`$shifts
Zcenter <- Z[which(shifts == 0)]
Zleft <- Z[which.min(shifts)]
Zright <- Z[which.max(shifts)]
# compute Fourier transform of Z
W <- fft(Z)
# compute autocorrelation on Z
Zacf <- drop(acf(Z, lag.max = length(Z)/1, plot = FALSE, type = "covariance")$acf)
# compute Fourier transform of the autocorrelation
Wacf <- fft(Zacf)
# compute first and second moments for Z, Zacf, Re(W), Im(W), Re(Wacf), Im(Wacf)
featuresRaw <- data.frame(
Z1 = mean(Z),
Z2 = sqrt(sum(Z^2)),
Zacf1 = mean(Zacf),
Zacf2 = sqrt(sum(Zacf^2)),
ReW1 = mean(Re(W)),
ReW2 = sqrt(sum(Re(W)^2)),
ImW1 = mean(Im(W)),
ImW2 = sqrt(sum(Im(W)^2)),
ReWacf1 = mean(Re(Wacf)),
ReWacf2 = sqrt(sum(Re(Wacf)^2)),
ImWacf1 = mean(Im(Wacf)),
ImWacf2 = sqrt(sum(Im(Wacf)^2))
)
# Standardize features
features <- caret:::predict.preProcess(RSeqR::prepFeatures, featuresRaw)
RSeqR::fftModel
RSeqR::fftModel$error
class(RSeqR::fftModel)
# Predict using stacked model
pred <- caretEnsemble:::predict.caretStack(RSeqR::fftModel, features)
pred
# Test each criteria for labeling "Control"
criteriaOne <- pval < .05
criteriaTwo <- Zcenter > 0
criteriaThree <- Zcenter > Zleft & Zcenter > Zright
criteriaFour <- pred == "Case"
# return results
list(
Features = featuresRaw %>%
tidyr::pivot_longer(dplyr::everything(),
names_to = "feature",
values_to = "raw_value") %>%
dplyr::inner_join(
tidyr::pivot_longer(
features, dplyr::everything(),
names_to = "feature",
values_to = "processed_value"
), by = "feature"
),
Criteria = list(
"PVal Significant" = criteriaOne,
"ZApex > 0" = criteriaTwo,
"ZApex > ZEdges" = criteriaThree,
"Predicted 'Case'" = criteriaFour
),
Verdict = ifelse(criteriaOne & criteriaTwo &
criteriaThree & criteriaFour,
"Case", "Control")
) %>%
return()
usethis::use_package("caretEnsemble")
usethis::use_package("caret")
library(RSeqR)
usethis::use_package("EnsDb.Hsapiens.v86")
library(Error: Package required but not available: ‘EnsDb.Hsapiens.v86’
)
library(EnsDb.Hsapiens.v86)
URL <- "https://rmapdb-data.s3.us-east-2.amazonaws.com/bigwigs/rseq-coverage-unstranded/SRX1025890_TC32_NT_DRIP.hg38.bw"
BW_FILE <- "SRX1025890.bw"
file.remove
download.file(URL, destfile=BW_FILE)
RSeqR::RSeqR(RSeqR::SRX1025890_peaks, coverage=BW_FILE,
genome="hg38", outputFile = "report.html")
annoData
annoData <- ChIPpeakAnno::toGRanges(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
annoData <- regioneR::toGRanges(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86
annoData <- GenomicFeatures::gene(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
annoData <- GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
annoData
annoData <- GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86) %>%
as.data.frame()
annoData
annoData <- GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86) %>%
as.data.frame() %>%
tibble::as_t
annoData <- GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86) %>%
as.data.frame() %>%
tibble::as_tibble()
annoData
annoData <- GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86) %>%
as.data.frame() %>%
dplyr::select(chrom=seqnames, start, end, strand, gene_name) %>%
tibble::as_tibble() %>%
dplyr::distinct(gene_name, .keep_all = TRUE)
annoData
peaks <- RSeqR::SRX1025890_peaks
peaks
peaksIntersect <- peaks %>%
as.data.frame() %>%
tibble::as_tibble()
peaksIntersect
peaksIntersect <- peaks %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::select(chrom=seqnames, start, end, width)
peaksIntersect
anno <- valr::bed_intersect(peaks, annoData)
anno <- valr::bed_intersect(peaksIntersect, annoData)
anno
peaksIntersect
annoData
seqlevelsStyle(edb) <- "UCSC"
edb <-  GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
seqlevelsStyle(edb) <- "UCSC"
edb
# Get the ensembl genes and conver to UCSC style
edb <-  GenomicFeatures::genes(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
seqlevelsStyle(edb) <- "UCSC"
# Wrangle to tibble
annoData <- edb %>%
as.data.frame() %>%
dplyr::select(chrom=seqnames, start, end, strand, gene_name) %>%
tibble::as_tibble() %>%
dplyr::distinct(gene_name, .keep_all = TRUE)
annoData
# Wrangle peaks to tibble
peaksIntersect <- peaks %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::select(chrom=seqnames, start, end, width)
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData)
anno
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData, suffix = TRUE)
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData, suffix = c("userPeaks", "EnsGenes"))
anno
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData, suffix = c("_userPeaks", "_EnsGenes"))
anno
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData, suffix = c("__userPeaks", "__EnsGenes"))
anno
txdb <- TxDb.Hsapiens.UCSC.hg38.knownGene
genes(txdb)
genes(txdb)
txdb
tidyTranscripts(txdb)
GenomicFeatures::genes
GenomicFeatures::genes(txdb)
?genes
GenomicFeatures::genes(txdb, columns="gene_symbol")
columns(txdb)
GenomicFeatures::genes(txdb, columns="GENEID")
GenomicFeatures::genes(txdb, columns="GENENAME")
columns(EnsDb.Hsapiens.v86)
?EnsDb.Hsapiens.v79
??EnsDb.Hsapiens.v79
# Available genomes
edbs <- list("hg38"=EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86,
"mm10"=EnsDb.Mmusculus.v75::EnsDb.Mmusculus.v79)
BiocManager::install("EnsDb.Mmusculus.v79")
# Available genomes
edbs <- list("hg38"=EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86,
"mm10"=EnsDb.Mmusculus.v79::EnsDb.Mmusculus.v79)
edbs
# Get the ensembl genes and conver to UCSC style
edb <-  GenomicFeatures::genes(edbs[[genome]])
genome <- "hg38"
# Get the ensembl genes and conver to UCSC style
edb <-  GenomicFeatures::genes(edbs[[genome]])
seqlevelsStyle(edb) <- "UCSC"
# Wrangle to tibble
annoData <- edb %>%
as.data.frame() %>%
dplyr::select(chrom=seqnames, start, end, strand, gene_name) %>%
tibble::as_tibble() %>%
dplyr::distinct(gene_name, .keep_all = TRUE)
# Wrangle peaks to tibble
peaksIntersect <- peaks %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::select(chrom=seqnames, start, end, width)
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData, suffix = c("__userPeaks", "__EnsGenes"))
anno
peaksIntersect
peaksIntersect$chrom
# Available genomes
edbs <- list("hg38"=EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86,
"mm10"=EnsDb.Mmusculus.v79::EnsDb.Mmusculus.v79)
# Get the ensembl genes and conver to UCSC style
edb <-  GenomicFeatures::genes(edbs[[genome]])
seqlevelsStyle(edb) <- "UCSC"
# Wrangle to tibble
annoData <- edb %>%
as.data.frame() %>%
dplyr::select(chrom=seqnames, start, end, strand, gene_name) %>%
tibble::as_tibble() %>%
dplyr::distinct(gene_name, .keep_all = TRUE) %>%
dplyr::mutate(chrom=as.character(chrom))
# Wrangle peaks to tibble
peaksIntersect <- peaks %>%
as.data.frame() %>%
tibble::as_tibble() %>%
dplyr::select(chrom=seqnames, start, end, width) %>%
dplyr::mutate(chrom=as.character(chrom))
# Intersect
anno <- valr::bed_intersect(peaksIntersect, annoData, suffix = c("__userPeaks", "__EnsGenes"))
BASE_UCSC <- 'http://hgdownload.soe.ucsc.edu/goldenPath/'
RLFS_BED_URL <- "https://rmapdb-data.s3.us-east-2.amazonaws.com/rlfs-beds/"
BASE_UCSC
paste0(toupper(substring(genomeTo, 1, 1), substr(genomeTo, 2)))
genomeTo <- "hg38"
genomeFrom <- "hg19"
url <- paste0(BASE_UCSC, genomeFrom, "/liftOver/", genomeFrom, "To", paste0(toupper(substring(genomeTo, 1, 1), substr(genomeTo, 2))))
genomeTo
url <- paste0(BASE_UCSC, genomeFrom, "/liftOver/", genomeFrom, "To", paste0(toupper(substring(genomeTo, 1, 1), substring(genomeTo, 2))))
url <- paste0(BASE_UCSC, genomeFrom, "/liftOver/", genomeFrom, "To", paste0(toupper(substring(genomeTo, 1, 1)), substring(genomeTo, 2)))
url
url <- paste0(BASE_UCSC, genomeFrom, "/liftOver/",
genomeFrom, "To",
paste0(toupper(substring(genomeTo, 1, 1)),
substring(genomeTo, 2)),
".over.chain.gz")
stopifnot(urlExists(url))
urlExists(url)
url
# Get the chain
rtracklayer::import.chain(url)
# Get the chain
rtracklayer::import.chain(gzfile(url))
# Get the chain
tmp <- tempfile()
tmp
download.file(url, destfile = tmp)
rtracklayer::import.chain(gzfile(tmp))
rtracklayer::import.chain(tmp)
unzip(tmp)
R.utils::gunzip(tmp)
download.file(url, destfile = paste0(tmp, ".gz"))
# Get the chain
tmp <- tempfile()
download.file(url, destfile = paste0(tmp, ".gz"))
R.utils::gunzip(paste0(tmp, ".gz"))
rtracklayer::import.chain(tmp)
chain <- rtracklayer::import.chain(tmp)
chain
#' Get Chain
#' Helper function that retrieves RLFS
#' @param genomeFrom the UCSC genome name to convert from.
#' @param genomeTo the UCSC genome name to convert to.
getChain <- function(genomeFrom, genomeTo) {
# Get URL
url <- paste0(BASE_UCSC, genomeFrom, "/liftOver/",
genomeFrom, "To",
paste0(toupper(substring(genomeTo, 1, 1)),
substring(genomeTo, 2)),
".over.chain.gz")
# Check if exists
stopifnot(urlExists(url))
# Get the chain
tmp <- tempfile()
download.file(url, destfile = paste0(tmp, ".gz"))
R.utils::gunzip(paste0(tmp, ".gz"))
chain <- rtracklayer::import.chain(tmp)
# Return as a GRanges object
return(
chain
)
}
chain <- getChain("hg19", "hg38")
chain
# Get the chain
chain <- getChain("hg38", "hg19")
chain
chain$chr22
ranges <- SRX1025890_peaks_hg19
ranges <- SRX1025890_peaks
ranges
# Get the chain
chain <- getChain("hg38", "hg19")
# Convert
rtracklayer::liftOver(ranges, chain = chain)
# Convert
lifted <- rtracklayer::liftOver(ranges, chain = chain)
lifted
# Convert
lifted <- rtracklayer::liftOver(ranges, chain = chain) %>%
unlist() %>%
unique()
lifted
SRX1025890_peaks
names(lifted)
duplicated(lifted)
which(duplicated(lifted))
lifted
lifted %>% as.data.frame()
rownames9lifted
rownames(lifted)
names(lifted)
table(names(lifted))
table(names(lifted)) %>% as.data.frame()
table(names(lifted)) %>% as.data.frame() %>% which(Freq > 1)
# Convert
lifted <- rtracklayer::liftOver(ranges, chain = chain) %>%
unlist() %>%
unique()
lifted %>% as.data.frame()
# Convert
lifted <- rtracklayer::liftOver(ranges, chain = chain) %>%
unlist()
# Convert
lifted <- rtracklayer::liftOver(ranges, chain = chain) %>%
unlist()
lifted
names(lifted)
nms <- names(lifted)
nms
unique(nms)
nms <- names(lifted) %>% unique()
lifted <- lifted[nms,]
lifted
lifted %>% as.data.frame()
genomeFrom
# Get the chain
chain <- getChain(genomeFrom, genomeTo)
ranges
ranges <- RSeqR::SRX1025890_peaks
# Lift Over
lifted <- rtracklayer::liftOver(ranges, chain = chain) %>%
unlist()
genomeFrom
genomeTo
genomeFrom <- "hg38"
genomeFrom <- "hg19"
ranges <- RSeqR::SRX1025890_peaks
# Get the chain
chain <- getChain(genomeFrom, genomeTo)
chain
liftUtil
RSeqR::SRX1025890_peaks
lifted
ranges <- RSeqR::SRX1025890_peaks
# Get the chain
chain <- getChain(genomeFrom, genomeTo)
genomeFrom
genomeFrom <- "hg38"
genomeTo <- "hg19"
# Get the chain
chain <- getChain(genomeFrom, genomeTo)
# Lift Over
lifted <- rtracklayer::liftOver(ranges, chain = chain) %>%
unlist()
lifted
# Force uniqueness
nms <- names(lifted) %>% unique()
lifted <- lifted[nms,]
lifted
genomeFrom
lifted
SRX1025890_peaks_hg19 <- lifted
usethis::use_data(SRX1025890_peaks_hg19, compress = "xz")
GenomicRanges::GRanges()
?GenomicRanges::GRanges
class(GenomicRanges::GRanges())
chain
class(chain)
class(EnsDb.Hsapiens.v86::EnsDb.Hsapiens.v86)
class(TxDb.Hsapiens.UCSC.hg38.knownGene)
stop("genome must be 'hg38' or 'mm10' or an object of class 'EnsDb' or 'TxDb'")
usethis::use_package("EnsDb.Hsapiens.v86", type = "suggests")
requireNamespace("EnsDb.Hsapiens.v86", quietly = TRUE)
requireNamespace("EnsDb.Hssapiens.v86", quietly = TRUE)
EnsDb.Hsapiens.v86
requireNamespace("EnsDb.Hsapiens.v86", quietly = F)
requireNamespace("EnsDb.Hssapiens.v86", quietly = F)
requireNamespace("EnsDb.Mmusculus.v79", quietly = TRUE)
requireNamespace("EnsDb.Mmuscuslus.v79", quietly = TRUE)
usethis::use_package("EnsDb.Hsapiens.v86", type = "suggests")
usethis::use_package("EnsDb.Hsapiens.v86", type = "suggests")
requireNamespace("EnsDb.Mmusculus.v79", quietly = TRUE)
usethis::use_package("EnsDb.Mmusculus.v79", type = "suggests")
library(RSeqR)
usethis::use_package("R.utils", type = "suggests")
requireNamespace("R.utils", quietly = TRUE)
dd <- requireNamespace("R.utils", quietly = TRUE)
dd
# Check if R.utils available
stopifnot(requireNamespace("R.utisls", quietly = TRUE))
# Check if R.utils available
if( ! requireNamespace("R.utils", quietly = TRUE)) {stop("R.utils is required. Please install it with install.packages('R.utils')")}
# Check if R.utils available
if( ! requireNamespace("R.utsils", quietly = TRUE)) {stop("R.utils is required. Please install it with install.packages('R.utils')")}
stop("EnsDb.Hsapiens.v86 is required.",
" Please install it with BiocManager::install('EnsDb.Hsapiens.v86')")
usethis::use_package("GenomicFeatures")
library(RSeqR)
library(RSeqR)
library(RSeqR)
library(RSeqR)
GenomeInfoDb::seqlevelsStyle
gc()
library(RSeqR)
